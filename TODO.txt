TODO

Hashlife all by yourself
	Central question: how do you know a macrocell can be destroyed?
	
		[
			Hypothesis: a macrocell won't outlive its parent or cause if:
				- a macrocell is referenced whenever it is returned form lookup (obviously), and
				- each child macrocell is referenced when getting the result (maybe excessive)

			Test theory (though it seems to work! ^_^)
				If the theory is wrong, the simulation may explode at an indeterminate point in the future
				Write a recursive inspection function that verifies there are no destroyed cells in the quadtree or its resulting quadtrees
		]

	Rokicki strategy
		when you fill up your cache, DUMP IT and repopulate it with the children and results of topCell
	LRU strategy
		while you exceed your cache, delete the least recently used nodes
		Problem: it seems as though the least recently used ones are still referenced somewhere
			"Long term memory of the system"
			Idea: multiple caches and LRUs?
				Along the lines of John Williamson's work
			Idea: manually count the references to a macrocell
				Store that value on the macrocell
				Increment and decrement it wherever
				Keep track of how many macrocells in the cache have zero references
				Only remove macrocells that have zero references
				Problem: it seems as thought the percent of macrocells with a reference > 0 increases
					Idea: fall back on Rokicki

	Followup question:
		What is there between the nonzero-ref macrocells and non-present macrocells?
		Is the "id" property causing trouble, preventing cache hits that would succeed in other implementations?
		Contact John Wililamson! Be polite.

	Switch to a pool of nodes, created up front
		Create every new node from lastNode

	The maximum memory shouldn't be some arbitrary value
		What to base it on, though?

	How does this operate?
		It would be nice to see the relationship between the contents of the cache and how useful they are
			At the moment we're just deleting the least useful ones
			We don't know whether we can delete MORE

		It would be nice to see how many function calls of each type occur per update
			Because it looks like the recursive functions are being called a whole lot less often than we thought!
		And it would be nice to know how deep each recursion went per update

	Afterwards
		Optimization of macrocell shape
			Replace state with identifying a leaf as the dead leaf, wire leaf, tail leaf or head leaf
				Removes the need for "state" on macrocell
			Remove "depth" from macrocell
				Or at least replace it with arg to recursive functions and then comment it out
			Comment out "destroyed" and "lastUseGen" properties

		Flatten
			Replace interlinked objects with addresses in a giant buffer

Download the 12/1/2021 episode from Twitch if you can!
	It went really well actually!
	Future Rezmason will be glad that you did!

When is HashLife ready for the main branch?
	Caching issue
	Interactive step size choice
		Replace turbo with dropdown:
			1x
			Turbo 1x
			Turbo 2x
			Turbo 4x
			Turbo 8x
			Turbo 16x
			etc
		Or maybe a weird slider
			Like a stick shift, I dunno

Sliders and selects should have labels in a11y mode

BUG: fix turbo-on issue in Firefox

BUG: fix focus-within issue with popup buttons in Chrome and Firefox

Photosensitivity warning
	Detect intense flickering, and replace with "epilepsy guard" color

Hybrid engine, conventional + HashLife
	Maybe an opportunity to create a more intuitive UI regarding speed control

New UI

EPISODE Milestone: gallery
	Most of the files are small!
	Load their data straight to canvas for preview images
	"Move" everything to RLE
		Load paths, authors from JSON

Milestone: better mobile experience
	Rethink the whole UI, really
		Popups are bad
		Toolbars are bad in portrait orientation

Milestone: pan with arrow keys
	pan: "Arrow(Left, Right, Up, Down)"
	pan faster: [shift arrow keys]

Milestone: drag-and-drop themes
	Merveilles themes
	Old Wireworld themes

Milestone: switch favicon to indicate sim is running

Milestone: EDITOR FUNCTIONALITY
	Research Computer Aided Circuit Design (thanks, Dad!)
	Look at Mike Ash's editor in classic Mac emulator
	Drawing wires, then painting electrons along wires
		Painting electrons could be like choosing a distance, a start point and an end point
	Simplify the construction and instantiation of COMPONENTS
		Components can contain multiple "snapshots" of electrons
		Global snapshots?
		Save and load format should persist all this
	Don't assume the user will run the simulator an exact number of steps just to recover an electron state
